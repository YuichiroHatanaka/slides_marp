---
marp: true
---

<!-- footer: "ロボットシステム学第6回" -->

# ロボットシステム学

## 第6回: ソフトウェアのテスト

千葉工業大学 上田 隆一


<p style="font-size:50%">
This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
<img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a>
</p>

---

<!-- paginate: true -->

## おさらいと今日やること

- おさらい: これまで説明してきたシェルの役割
    - ユーザーから文字を受け取ってコマンドを実行する
    - コマンドを見つける（`PATH`）
- 今日やること: シェルの<span style="color:red">プログラミング言語としての側面</span>を学習
    - コマンドを関数のように組み合わせて制御
    - ファイルにコマンドを動かす手順（<span style="color:red">シェルスクリプト</span>）を書く
    - シェルスクリプトを使ってplus_stdinが正しいかどうかをテスト

---

## 1. シェルの変数

---

### 基本事項

- シェルは，`変数名=文字列`で，文字を記憶
    ```bash
    ### 例 ###
    $ X=我々は宇宙人だ   # 変数のセット
    ```
- `${変数名}`で値に置換
    ```bash
    ### 例 ###
    $ echo ${X}ぜ！      # 変数を値に
    我々は宇宙人だぜ！
    $ echo $X            # {}は省略できる（こともある）
    我々は宇宙人だ
    $ echo '$X' # 値にしないときはシングルクォートで囲う（``と混同注意）
    $X
    ```
    ```bash
    ### {} が省略できない例 ###
    $ echo ${X}Z
    我々は宇宙人だZ
    $ echo $XZ
                            #変数「XZ」と解釈されるのでなにも出力されない
    ```

---

### コマンドの出力を変数に

- `変数名=$(コマンド)`
 - 通常は標準出力に出るコマンドの出力を文字列として変数に格納
 - 例: `ls`の出力を変数`A`に　　　　　　　　　　　　　　
    ```bash
    $ A=$(ls)
    $ echo $A
    README.md plus_stdin  # 注意: 出力は各自異なります．
    ```


---

## 2. コマンドの終了ステータス

---

### コマンドによる正常終了・異常終了の伝達

- コマンドは人に対してだけでなく，シェルにエラーの有無を伝達
- 方法 
    - <span style="color:red">終了ステータス</span>と呼ばれる整数値で伝達
        - シェルは<span style="color:red">`?`</span>というパラメータにコマンドの終了ステータスを記録
     - 例: `ls`の出力
        ```bash
        $ ls /etc/passwd   # 存在するファイルをls
        /etc/passwd
        $ echo $?          # ?に$をつけると値に置き換わる
        0                  # ?の値はゼロ
        $ ls aaaaaaaa      # 存在しないファイルをls
        ls: 'aaaaaaaa' にアクセスできません: そのようなファイルやディレクトリはありません
        $ echo $?
        2                  # ゼロでない値が入る．
        ```

---

### `plus_stdin`の終了ステータス

- これまで書いてきた`plus_stdin`も終了ステータスをシェルに伝達
    - Pythonが裏でやっているので，任せておいて問題ない
    ```bash
    $ seq 3 | ./plus_stdin    # 正常な入力
    6
    $ echo $?
    0
    $ echo あ | ./plus_stdin  # ひらがなを入力してエラーを起こさせる
    （エラーの表示．省略．）
    $ echo $?
    1
    ```

<center>なんのために終了ステータスがあるか？→あとで説明</center>

---

## 3. テストコマンド

- 以下のいずれかで，文字列を比較可能　　　　　
     - その1: `test 比較したい文字列 = 比較したい文字列`
     - その2: `[ 比較したい文字列 = 比較したい文字列 ]`
     - その3: `[[ 比較したい文字列 = 比較したい文字列 ]]`
     - 例（その1〜3の違いには細かい話はありますが，　　ここでは「その2」だけ）
        ```bash
        $ a=山田
        $ [ "$a" = 上田 ]       # [ はコマンドなので，引数はくっつけないようにしましょう．
        $ echo $?               #終了ステータスで確認
        1
        $ [ "$a" = 山田 ]
        $ echo $?
        0
        ```

---

## 4. 簡単なシェルスクリプトの記述

- コマンドの起動手順をファイルに書いてみましょう
    - 我々がこれから書くのはBashのスクリプト
     （Bashはシェルなので，シェルスクリプトの一種）　
    - ここからはおそらく一気に覚えられないので見様見真似で書いて実行
    - 読めるようにはなってください

---

### シェルスクリプトを作ってみる


- テストコマンドの例をファイルに保存して実行してみましょう
 - 「`yamada.bash`」というファイルに，次のように記述
    ```bash
    #!/bin/bash
    　 
    a=山田
    [ "$a" = 上田 ]       
    echo $?               
    [ "$a" = 山田 ]
    echo $?
    ```
 - `chmod`してPythonのスクリプトと同様に実行
    ```bash
    $ chmod +x yamada.bash
    $ ./yamada.bash
    1
    0
    ```

---

## 5. シェルの関数

- 基本的な関数の書き方: 名前のうしろに`()`をつけて，`{}`の中に処理を記述
- 第`n`引数を`${n}`で受け取り
    - 例: `ng`という関数を作り、呼び出してみる（ファイル名は`test.bash`）
    ```bash
    #!/bin/bash
    　
    ng () {
            echo ${1}行目が違うよ  #$1はngの1番目の引数
    }
    　
    ng 123
    ```
    - 実行
    ```bash
    $ chmod +x ./test.bash
    $ ./ng.bash
    123行目が違うよ
    ```

--- 

### コマンドと関数の連携

- `[`が失敗したら`ng`を呼び出す
    - 例（ファイル名: `test.bash`）
    ```bash
    #!/bin/bash
    　
    ng () {
            echo ${1}行目が違うよ
            ret=1                   #追加
    }
    　
    ret=0
    a=山田
    [ "$a" = 上田 ] || ng "$LINENO"  # LINENOは，この行の行番号の入る変数
    [ "$a" = 山田 ] || ng "$LINENO"  # ngに第一引数として$LINENOを付与
    　
    exit $ret     # このシェルスクリプトの終了ステータスを返して終了
    ```
    - `||`（OR記号）: 左側のコマンドが異常終了したら右側を実行

---

### 実行結果

```bash
$ ./test.bash
10行目が違うよ
$ echo $?
1
```

---

## 6. 初歩的なテスト

やっと本題

---

### ここで言うテストとは

- プログラムが意図通りに動作するかを<span style="color:red">別のプログラムを書いて</span>テストすること
 - 「別のプログラム」の流れ
        1. 関数やプログラムに引数で，あるいは標準入力からデータを入力
        2. 出力を記録
        3. 期待した出力と一致するか比較　

面倒だと思いますか❓

---

### テストがないと辛い

- 例: 「プログラムに機能をどんどん追加していったら，　　最初に書いた部分がうまく動かなくなった！」
 - <span style="color:red">→こまめにテストを実行してたら早期発見していた．</span>
 - こういう目的のテストを特に<span style="color:red">「リグレッションテスト（退行テスト）」</span>と言う．これからそれをやる．　
- 例: コードがどんな出力をすべきなのか忘却
 - テストがあると手軽に判明
 - 例えば範囲の条件が「○○未満」なのか「○○以下」なのかなどは忘れやすいし，境界条件のテストとして記述しておくとよい

---

### こういう開発スタイルに早く移行しましょう

1. こまめにテスト
2. テストに通ったらGitにコミット
3. テストに失敗して，原因不明なら前回のコミットに退却
 - `git restore`
4. さらに細かくテスト

予告: 最初の課題ではこのような経緯の分かるリポジトリを各自提出してもらいます！（あとから慌てても無理．コピー不可能）

---

### リグレッションテストの書き方

- テストの流れ
    1. テスト対象の関数やプログラム（コマンド）に何か入力
 - 今回は標準入力を使って`plus_stdin`をテスト
    2. 出力を，あらかじめ期待していたものと比較
    3. <span style="color:red">比較の結果違っていたら，異常終了</span>　
 - 異常終了 = 終了ステータス非ゼロ　
- テストの道具
 - 一般には，使う言語のテスト機能やライブラリを利用
 - 今回はシェルスクリプトを利用
 - 理由: 
 - 簡単で，シェルスクリプトは他の用途にも応用可能
 - 終了ステータスを使う点で，他のものと本質的な違いがない
 - コマンドを記述した言語と無関係に，同じ方法で入出力をテスト可能

---

### 準備

1. `plus_stdin`を`plus`に改名しておく$\rightarrow$<span style="color:red">コミットを</span>
 - 注意: テストと無関係です．
2. 次のようなシェルスクリプトを書いて動作確認
 - `plus`と同じ場所に．名前は`test.bash`で．
    ```bash
    #!/bin/bash
    　
    seq 5 | ./plus
    ```
 - 実行すると`15`と出力$\rightarrow$<span style="color:red">コミットを</span>
3. とりあえずGitHubにpushしておく
 - <span style="color:red">こまめに！</span>

---

### テストの記述

- 出力を変数に格納
- テストコマンドで正解と比較
    ```bash
    #!/bin/bash
    　
    out=$(seq 5 | ./plus)
    　
    [ "${out}" = 15 ]
    ```
- 動作確認
    ```bash
    $ ./test.bash 
    $ echo $?
    0
    ```
 - 15を14に変えて`echo $?`で`1`と出ることも確認$\rightarrow$<span style="color:red">コミットを</span>
 - なんで判定に終了ステータスを使うのかは次回判明

---

### さらなる改良


- 改良点
 - 人間にも成否が分かるように/テスト項目を追加可能に
- さきほど習得した関数を利用
 - 前回学んだ著作権やライセンスの設定も
    ```bash
    #!/bin/bash
    # SPDX-FileCopyrightText: 2022 Ryuichi Ueda
    # SPDX-License-Identifier: BSD-3-Clause
    　
    ng () {
            echo NG at Line $1
            res=1
    }
    　
    res=0
    　
    ### I/O TEST ###
    out=$(seq 5 | ./plus)
    [ "${out}" = 14 ] || ng ${LINENO}
    　
    [ "$res" = 0 ] && echo OK        # &&（AND記号）は左側が成功すると右側を実行
    exit $res
    ```

---

### 動作確認

- 失敗した行と終了ステータスを確認
    ```bash
    ./test.bash
    NG at Line 12
    $ echo $?
    1
    ```
 - 動作確認したらテストコマンドで比較する数を`15`に戻して動作確認
 - `OK`と出るか．終了ステータスは`0`か．
 - <span style="color:red">commit & push</span>

---

### シェルスクリプトの挙動の確認

- `-x`や`-v`でシェルスクリプトの動作を観察可能　　　
    ```bash
    #!/bin/bash -xv        <- シバンの後ろに-xvと書いて-xと-vをセット
    （以下略）
    ```
 - 動作確認
        ```bash
        $ ./test.bash 
        （略）
        res=0
        + res=0
       　 
        ### I/O TEST ###
        out=$(seq 5 | ./plus)
        ++ seq 5
        ++ ./plus
        + out=15
        [ "${out}" = 15 ] || ng ${LINENO}
        + '[' 15 = 15 ']'
       　 
        [ "$res" = 0 ] && echo OK
        + '[' 0 = 0 ']'
        + echo OK
        OK
        exit $res
        + exit 0
        ```


---

### テスト項目の追加

- 不正な入力に対する挙動もテストするとよい 　　　　　
 - 入力が正しいような出力をしていないか
 - 特定の終了ステータスを返しているかどうか
        ```bash
        #!/bin/bash -xv
        （略）
        ### I/O ###
        out=$(seq 5 | ./plus)
        [ "${out}" = 15 ] || ng ${LINENO}
          　 
        ### STRANGE INPUT ###
        out=$(echo あ | ./plus)
        [ "$?" = 1 ]      || ng ${LINENO}
        [ "${out}" = "" ] || ng ${LINENO}
          　 
        out=$(echo | ./plus) #空文字
        [ "$?" = 1 ]      || ng ${LINENO}
        [ "${out}" = "" ] || ng ${LINENO}
          　 
	[ "$res" = 0 ] && echo OK
        exit $res
        ```
 - 注意: 終了ステータスはコマンドを実行したらすぐ確認（変わってしまうので．）

---

## まとめ・後始末

- まとめ
 - シェルスクリプトを記述
 - 終了ステータス，変数，テストコマンド，関数
 - リグレッションテストの記述
 - プログラムと一緒に少しずつ書いていく
 - ROSのように標準入出力を使わないものについては第11回で　
- 後始末
 - `yamada.bash`は削除してpush
